#!/usr/bin/env python2.6

"""

Main routine for Induced Radiation Damage procedure

Mandatory fields:

-e --edna <edna folder name >
   For the workflow: complete path for the XML StrategyResult file can be used.
-p --path <xds path> for the current wedge (the one just collected).
    xds_path is of the form: [/path/path/]xds_<wedge_name>w<wedge_number>_run<run_number>_<dataset_number>

Optional fields:

-h --help : show help message
-i --ignore: this will ignore even wedges (e.g. crystal1w2_run1_1) and will process only odd wedges (1,3,5,...,21). Use this when burning wedges are even.
-c --current <integer> : current wedge entry in the queue (if absent comes from: xds_crystal1w<current>_run1_1)
-f --first <integer>: first element in the queue (default 1)
-l --last <integer>: of n elements in the queue (default 21)
-s --see : see results of the burning strategy (no jobs are sent to condor/oar). Current wedge is used as last wedge (either from the -p <xds path> or -c parameter). This bit of code is called by default when current wedge == last wedge.
-u --unset <list of ints>: When showing the results (i.e. processing the last wedge from the queue: current == last), the user may ignore some "dodgy" wedges: e.g. "1,5,7"
-r --raddose <string>: raddose keywords file (file with entries of the form <keyword> = <value>, where keyword is defined in raddose manual, e.g.: FLUX = 10e12). By default the software looks for the file raddose.ini in the path. If the file exists, the keywords present in the file will replace the raddose script generated by EDNA. The new raddose file will be created as <wedge_name>_raddose.sh.
-d --draw : only draws the plot to an image file, doesn't open an X window (default is open the X window)
-n --config <config ini file> : default value config.ini
-t --resolution : resolution for calculate intensity decay. Default is the value used in strategy
-b --bfactor : initial B-Factor for calculate intensity decay. Default is the fitted value for beta.


Output files:
<wedge_name>.png - plot
<wedge_name>.csv - csv file with all the important details
<wedge_name>_real.png - plot for real dose rate if raddose.ini exists
/tmp/InducedRadDam.log - log file

Note: the calculations and graphs are only executed when: current <integer> == last <integer>

"""

# find . -maxdepth 1 -name "EDApplication_*.log" | xargs grep -m 1 template
#./EDApplication_20100929-115531.log:20100929-115547  MOSFLM : Image template          : ref-ins1_1_###.img
#./EDApplication_20100929-121351.log:20100929-121403  MOSFLM : Image template          : ref-ins2_1_###.img
#./EDApplication_20100929-122526.log:20100929-122537  MOSFLM : Image template          : ref-ins3_1_###.img
#./EDApplication_20100929-124018.log:20100929-124034  MOSFLM : Image template          : ref-inb1_9_###.img
#./EDApplication_20100929-124259.log:20100929-124311  MOSFLM : Image template          : ref-inb1_10_###.img
#./EDApplication_20100929-131325.log:20100929-131337  MOSFLM : Image template          : ref-inb2_1_###.img
#./EDApplication_20100929-131948.log:20100929-131958  MOSFLM : Image template          : ref-inb3_1_###.img
#./EDApplication_20100929-140906.log:20100929-140917  MOSFLM : Image template          : ref-inb4_1_###.img


import sys
import getopt
import os.path
import os
import subprocess as sub
import time
import getpass
import pprint as pp
import datetime


# local imports
import XDS
import condor
import oar
import best
import localLogger
import ini
import raddose
import wedgeHandler
import ednaHandler
import burntWedgesHandler
import plot
import data
import fitting

__author__ = "Ricardo M. Ferraz Leal"
__copyright__ = "Copyright 2011, European Synchrotron Radiation Facility"
__credits__ = ["Ricardo M. Ferraz Leal", "Alexander N. Popov", "Gleb P. Bourenkov",
                    "Olof Svensson","Darren Spruce","Matias Guijarro"]
__license__ = "GPL"
__version__ = "1.0.1"
__maintainer__ = "Ricardo M. Ferraz Leal"
__email__ = "ricardo.leal@esrf.fr"
__status__ = "Production"


class Usage(Exception):
    def __init__(self, msg):
        self.msg = msg

def main(argv=None):
    """
    Main Function
    """
    if argv is None:
        argv = sys.argv
    # Variables
    ignore = False
    ednaFolderName = None
    wedgeFolderPath = None
    currentQueueItem = None
    firstQueueItem = 1
    lastQueueItem = 21 # of
    see = False
    raddoseFileName = None
    draw = False
    unsetList = []
    wedgeFolderTemplate = None
    configIniFileName = 'config.ini' 
    resolution = None
    bfactor0 = None
    
    try:
        try:
            opts, args = getopt.getopt(argv[1:], "hie:p:c:l:sr:f:du:t:n:b:", ["help", "ignore", "edna","wedgeFolderPath","current","last","see","raddose","first","draw","unset","resolution","config","bfactor"])
        except getopt.error, msg:
            raise Usage(msg)

        # option processing
        for option, value in opts:
            if option in ("-h", "--help"):
                raise Usage(__doc__)
            elif option in ("-i", "--ignore"):
                ignore = True
            elif option in ("-e", "--edna"):
                ednaFolderName = value
            elif option in ("-p", "--wedgeFolderPath"):
                wedgeFolderPath = value
            elif option in ("-c", "--current"):
                currentQueueItem = int(value)
            elif option in ("-l", "--last"):
                lastQueueItem = int(value)
            elif option in ("-s", "--see"):
                see = True
            elif option in ("-r", "--raddose"):
                raddoseFileName = value
            elif option in ("-f", "--first"):
                firstQueueItem = int(value)
            elif option in ("-d", "--draw"):
                draw = True
            elif option in ("-n", "--config"):
                configIniFileName = value
                print 'Using config file: %s' % configIniFileName
            elif option in ("-t", "--resolution"):
                resolution = float(value)
            elif option in ("-b", "--bfactor"):
                bfactor0 = float(value)
            elif option in ("-u", "--unset"):
                try :
                    unsetListStr = value.split(',')
                    unsetList = [int(i) for i in unsetListStr]
                except :
                    print >> sys.stderr, 'Make sure that the option -u / --unset is followed by a list separated by commas'
                    return 2
                    
                    
                
            
         
    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        print >> sys.stderr, ""
        print >> sys.stderr, "For help use the -h or the --help option."
        print >> sys.stderr, ""
        return 2
    
    
    #===============================================================================
    # Fun starts here!!  
    #===============================================================================
    
    # Mandatory initialisations!
    ini.Ini(configIniFileName)
    myLog = localLogger.LocalLogger()
    #
    
    if ednaFolderName is None and (wedgeFolderPath is None or wedgeFolderTemplate is None):
        myLog.logger.info("InducedRadDam v0.3")
        myLog.logger.info("Both ednaFolderName and wedgeFolderPath are mandatory!")
        sys.exit(0)
    
    
    # get wedge details from the wedgeFolderPath
    wedge = wedgeHandler.WedgeHandler(wedgeFolderPath)
    
    
    wedge.buildEdnaFolderPath(ednaFolderName)
    
    if currentQueueItem is None :
        currentQueueItem = wedge.subWedgeNumber
    
    if see is True :
        lastQueueItem = currentQueueItem
    
    myLog.logger.debug("Queue Items: current %d ; first: %d ; from %d " 
                       % (currentQueueItem,firstQueueItem,lastQueueItem))
    
    # Now process folder are generated for burning cycles
    # since there's no image being collected it should not be created
    # This is a workaround.
    if ignore is True and currentQueueItem % 2 == 0 :
        # even wedge
        myLog.logger.debug("Current wedge is even: %d. Ignoring it...", currentQueueItem)
        if os.path.exists(wedge.wedgeFolderPath) :
            myLog.logger.debug("Backing up folder: " + wedge.wedgeFolderPath)
            os.system("mv %s %s_bak" % (wedge.wedgeFolderPath,wedge.wedgeFolderPath) )
        sys.exit(0)
    
    myLog.logger.info("Processing wedge %d from %d...",currentQueueItem,lastQueueItem)      
    
    # Just an history of what has been done in this folder
    # to delete / move in the future
    f = open(os.path.join(wedge.processFolderPath,'history.log'),'a')
    #f.write(datetime.datetime.now().strftime("%Y-%m-%d %H:%M") + '\t' + wedge.wedgeFolderName + '\t' + ednaFolderName + '\n')
    f.write("%s -> %s\n" %(datetime.datetime.now().strftime("%Y-%m-%d %H:%M") ," ".join(argv)))
    f.close()
    
    
    # edna stategy
    # parses the burn strategy file
    # For Sandor
    # if ednaFolderName is a complete path to an XML file don't build the path
    if not os.path.isfile(ednaFolderName):
        ednaStrategyOutputXmlFile =  os.path.join(wedge.ednaFolderPath,ini.Ini().getPar("EDNA","edna_control_interface_to_mxcube_data_output"))
    else :
        ednaStrategyOutputXmlFile = ednaFolderName
        
    ednaStrategy = ednaHandler.EdnaHandler(ednaStrategyOutputXmlFile)
    ednaStrategy.parseFile()
    
    #=======================================================================
    # Processing data in parallel
    #=======================================================================    
    if see is False :
        # Process de data in coral / oar
    
        # Prepare XDS file
        xds = XDS.XDS(wedge.wedgeFolderPath)
        xds.setCrystal(ednaStrategy.getCellAsString(), ednaStrategy.getSpaceGroupNumber())
        referenceWedgeNumber = ini.Ini().getPar("XDS","xds_reference_data_set_wedge_number")
        
        if currentQueueItem != firstQueueItem and referenceWedgeNumber is not None:
            xds.setReferenceDataSet(wedge.getWedgeFolderName(int(referenceWedgeNumber)))
            
        xds.prepareIniFile()    
        
        # Prepare best -DamPar (only calculates b-factor)
        bestHandler = best.Best(wedge.wedgeFolderPath)
        bestBatchFile = bestHandler.prepareBatchFile(ednaStrategy.getDetectorType(), ednaStrategy.getExposureTime())
        
        if "condor" in ini.Ini().getPar("GENERAL","run_through") : 
            # Prepare Condor files
            myLog.logger.debug("Preparing condor")
            condorHandler = condor.Condor(wedge.wedgeFolderPath)
            jobFilePath = condorHandler.createJob(ini.Ini().getPar("XDS","xds_bin"),currentQueueItem)
            condorHandler.createDagWithPostScript(jobFilePath, bestBatchFile)
            condorHandler.launchDag()
        elif "oar" in ini.Ini().getPar("GENERAL","run_through") :
            myLog.logger.debug("Preparing OAR")
            oarHandler = oar.Oar(wedge.wedgeFolderPath)
            jobFilePath = oarHandler.createJob(ini.Ini().getPar("XDS","xds_bin"),bestBatchFile)
            oarHandler.launchJob(jobFilePath)
        else :
            myLog.logger.error("No valid High-Throughput Computing defined in configuration file: " + ini.Ini().getPar("GENERAL","run_through"))
            sys.exit(0)
    
        
        # last element in the queue
        if  currentQueueItem == lastQueueItem :
            # condor_wait returns 1 if unrecoverable errors occur, such as a missing log file, if the job does not exist in the log file, or the user-specified waiting time has expired.
            myLog.logger.info("Condor/OAR waiting for jobs to stop...")
            
            maxCycles = ini.Ini().getPar("GENERAL","number_of_cycles_to_wait_for_processing") 
            for i in range(0,int(maxCycles)):
                # condor entries for current user
                if "condor" in ini.Ini().getPar("GENERAL","run_through") : 
                    command = ini.Ini().getPar("CONDOR","condor_q") + ' | grep ' + getpass.getuser() + ' | egrep \'condor_dagman|xds\''
                elif "oar" in ini.Ini().getPar("GENERAL","run_through") :
                    command = ini.Ini().getPar("OAR","oar_status") + ' -u ' + getpass.getuser() + ' | grep inducedRadDam'
                    
                # execute command and get output
                p = sub.Popen(command,stdout=sub.PIPE,stderr=sub.PIPE,shell=True)
                output, errors = p.communicate()            
                if errors is not None and len(errors)>0 :
                    myLog.logger.error("Error getting condor/oar Queue: " + command)
                    myLog.logger.error(errors)
                if output is not None and len(output)>0 :
                    myLog.logger.info(command + ':\n'+ output)                
                    myLog.logger.info("Sleeping for 10 seconds: Waiting for the jobs to stop...")
                    time.sleep(10)
                    if maxCycles == i + 1 :
                        myLog.logger.error("I have waited too much for the jobs to finish: Giving up...")
                        sys.exit(2)
                else :
                    myLog.logger.info("Jobs finished")
                    break
        
    #=======================================================================
    # Data Analysis / plotting
    #=======================================================================
    if  currentQueueItem == lastQueueItem or see is True:
        # analyse the data in all folders:
        myLog.logger.info("Analysing all data...")
        
        # parse results from XDS and Best -bfactoronly
        # put results in list of dictionaries
        burntWedge = burntWedgesHandler.BurntWedgesHandler(wedge)
        
        #TODO
        #Need to put somewherea way to see which wedges failed in the burwedgehandler!!!!
        
        if ignore is True :
            # Only wedge odd numbers are valid
            wedgeRange = range(firstQueueItem,lastQueueItem+1,2)
        else :
            wedgeRange = range(firstQueueItem,lastQueueItem+1)
        
        # remove possible unset wedges:
        if unsetList : # not empty
            wedgeRange = [i for i in wedgeRange if i not in unsetList]
        
        # Calculate average intensities, relative scales, etc...
        
        if resolution is None:
            resolution =  ednaStrategy.subWedgesList[-1]['strategyResolution']
            myLog.logger.info("Using resolution from strategy: %.2f A" % resolution)
        else :
            myLog.logger.info("Using resolution from input: %.2f A" % resolution)
        burntWedge.parseWedges(wedgeRange, resolution)
        
        
        # Raddose bit
        # If raddose keyword  file (raddose.ini) exists, calculate real absorbed dose
        # puts it in a dict: raddose.results
        rad = None
        if raddoseFileName is None :
            raddoseFileName = ini.Ini(configIniFileName).getPar("RADDOSE","default_input_file")
        raddoseFilePath = ini.Ini().testIfFileExistsInFolders(raddoseFileName,[wedge.processFolderPath,wedge.baseFolderPath])
        
        if raddoseFilePath is not None :
            rad = raddose.Raddose(wedge.processFolderPath,wedge.ednaFolderPath,raddoseFilePath)
            rad.readFileWithRaddoseKeywords()
            rad.modifyRaddoseRunScript(os.path.join(wedge.processFolderPath,wedge.wedgeName+'_raddose.sh'))
            rad.runAndParseRaddoseOutput()
        #
        if rad is None or rad.realAbsorbedDoseRate is None :
            ednaStrategy.doCalculations()
        else:
            ednaStrategy.doCalculations(rad.realAbsorbedDoseRate)
            
        #
        # data structure to hold all data
        #
        dataCollected = data.Data()
        dataCollected.addListOfDcits(ednaStrategy.subWedgesList)
        #myLog.logger.debug('burntWedge List:\n%s'%pp.pformat(burntWedge.wedgeList, indent=2,  depth=3))
        # Needs to be intersection and not union as some of the burned wedges may have failed (e.g. XDS failed)
        dataCollected.mergeListOfDictsIntersection(burntWedge.wedgeList, 'subWedgeNumber')
        
         
        wedge.convertVariablesToDict()
        dataCollected.replicateDicToLisOfDicts(wedge.wedgedict)

        if rad is not None and rad.results is not None : 
            dataCollected.replicateDicToLisOfDicts(rad.results)
        
        #
        #


        
        #
        # Create a new object data with data to plot
        # This object will handle a subset of data from the previous 
        from copy import deepcopy
        dataToPlot = data.Data()
        dataToPlot.addListOfDcits(deepcopy(dataCollected.listOfDicts))        
        dataToPlot.removeDicWhereKeyNotIn('subWedgeNumber',wedgeRange) #
        
        #myLog.logger.debug('Data to plot:\n%s'%pp.pformat(dataToPlot.listOfDicts, indent=2,  depth=3))
         
       
        #pp.pprint(dataToPlot.listOfDicts)
        if len(wedgeRange) < len(dataToPlot.listOfDicts):
            myLog.logger.error('Number of entries in the Data to plot is superior to the wedge range!!')
            sys.exit(2)
        
        #
        # Data treatment
        accumulatedDose = dataToPlot.getListOfValuesFromKey('accumulatedDose')
        overallBFactor = dataToPlot.getListOfValuesFromKey('overallBFactor')
        
        #
        # Beta
        # 
        
        overallBFactorFitting = fitting.Fitting(accumulatedDose,overallBFactor)
        slopes,x0s = overallBFactorFitting.doMultipleLinearFitting2Coeffs()
        dataToPlot.addListOfValuesWithKey('beta', slopes)
        dataToPlot.addListOfValuesWithKey('initialBFactor', x0s)
        # Initial B factor for D = 0        
        relativeOverallBFactor =  burntWedge.createRelativeOverallBFactorField(x0s[-1],overallBFactor)
        dataToPlot.addListOfValuesWithKey('relativeOverallBFactor', relativeOverallBFactor)
         
        #Real Beta
        if rad is not None and rad.results is not None : 
            realAccumulatedDose = dataToPlot.getListOfValuesFromKey('realAccumulatedDose')
        
            realOverallBFactorFitting = fitting.Fitting(realAccumulatedDose,overallBFactor)
            slopes,x0s = realOverallBFactorFitting.doMultipleLinearFitting2Coeffs()
            dataToPlot.addListOfValuesWithKey('realBeta', slopes)
            dataToPlot.addListOfValuesWithKey('realInitialBFactor', x0s)
            
            # Initial B factor for D = 0
            realRelativeOverallBFactor =  burntWedge.createRelativeOverallBFactorField(x0s[-1],overallBFactor)
            dataToPlot.addListOfValuesWithKey('realRelativeOverallBFactor', realRelativeOverallBFactor)
        
        
        #
        # Alpha (from relative Scale)
        #
        
        relativeScale = dataToPlot.getListOfValuesFromKey('relativeScale')
                
        relativeScaleFitting = fitting.Fitting(accumulatedDose,relativeScale)
        coeffsA,coeffsB = relativeScaleFitting.doMultipleExponentialSquared2coeffsFitting()
        dataToPlot.addListOfValuesWithKey('relativeScaleS0', coeffsA)
        dataToPlot.addListOfValuesWithKey('alpha', coeffsB)
        # Real Alpha
        if rad is not None and rad.results is not None : 
            realRelativeScaleFitting = fitting.Fitting(realAccumulatedDose,relativeScale)
            coeffsA,coeffsB = realRelativeScaleFitting.doMultipleExponentialSquared2coeffsFitting()
            dataToPlot.addListOfValuesWithKey('realRelativeScaleS0', coeffsA)
            dataToPlot.addListOfValuesWithKey('realAlpha', coeffsB)
        
        #
        # invRelativeScale
        #
        
        
        # Wil create the invRelativeScale field
        invRelativeScale = burntWedge.createRelativeScaleField(relativeScaleFitting.coefficients[0],relativeScale)
        dataToPlot.addListOfValuesWithKey('invRelativeScale',invRelativeScale)
        
        
        # Real Inverted Scales Alpha
        # This will be just for plotting purposes. No need to store this in the data structure
        # S0 will be 1, alpha value is the same!!! We dont need to fit the data but use the
        # parameters from the previous fitting
        invRelativeScale = dataToPlot.getListOfValuesFromKey('invRelativeScale')
        invRelativeScaleFitting = fitting.Fitting(accumulatedDose,invRelativeScale)
        invRelativeScaleFitting.setContinuousX()
        
        # get alpha from the fitting in not relative data
        invRelativeScaleFitting.coefficients = [relativeScaleFitting.coefficients[1]]
        invRelativeScaleFitting.function = invRelativeScaleFitting.funcExponentialSquaredNegative1coeffs
        
        #invRelativeScaleFitting.exponentialSquared1CoeffsNegativeFitting()
        
        invRelativeScaleFitting.setContinuousY()
        #invRelativeScaleFitting.determineError()
        if rad is not None and rad.results is not None :
            realInvRelativeScale = burntWedge.createRelativeScaleField(realRelativeScaleFitting.coefficients[0],relativeScale)
            dataToPlot.addListOfValuesWithKey('realInvRelativeScale',realInvRelativeScale)
        
            realInvRelativeScale = dataToPlot.getListOfValuesFromKey('realInvRelativeScale') 
            realInvRelativeScaleFitting = fitting.Fitting(realAccumulatedDose,realInvRelativeScale)
            realInvRelativeScaleFitting.setContinuousX()
            
            realInvRelativeScaleFitting.coefficients = [realRelativeScaleFitting.coefficients[1]]
            realInvRelativeScaleFitting.function = realInvRelativeScaleFitting.funcExponentialSquaredNegative1coeffs
        
            #realInvRelativeScaleFitting.exponentialSquared1CoeffsNegativeFitting()
            
            realInvRelativeScaleFitting.setContinuousY()
            #realInvRelativeScaleFitting.determineError()
            
        #
        # D_{1/2}
        # Calculate Dose One Half (D1/2)
        #
        

        # first calculate relativeAverageIntegratedIntensity:
        averageIntegratedIntensity = dataToPlot.getListOfValuesFromKey('averageIntegratedIntensity')
        relativeAverageIntegratedIntensity = burntWedge.createRelativeAverageIntegratedIntensityField(1,invRelativeScale[0],averageIntegratedIntensity)
        dataToPlot.addListOfValuesWithKey('relativeAverageIntegratedIntensity',relativeAverageIntegratedIntensity)

        relativeAverageIntegratedIntensityFitting = fitting.Fitting(accumulatedDose,relativeAverageIntegratedIntensity)
        
        relativeAverageIntegratedIntensityFitting.setContinuousX()
        if bfactor0 is None:
            bfactor0 = overallBFactorFitting.coefficients[1]
        
        relativeAverageIntegratedIntensityFitting.calculateTheoreticalIntensityDecay(beta = overallBFactorFitting.coefficients[0],
                                                                             gamma = invRelativeScaleFitting.coefficients[0],
                                                                             initialWilsonB= bfactor0)
        relativeAverageIntegratedIntensityFitting.doTheoreticalIntensityDecayCurve(resolution=resolution)
        d = relativeAverageIntegratedIntensityFitting.getTheoreticalDOneHalf()
        dsOneHalf = [d] * len(accumulatedDose)
        dataToPlot.addListOfValuesWithKey('D1/2',dsOneHalf)
        
        if rad is not None and rad.results is not None :
            realRelativeAverageIntegratedIntensity = burntWedge.createRelativeAverageIntegratedIntensityField(1,realInvRelativeScale[0],averageIntegratedIntensity)
            dataToPlot.addListOfValuesWithKey('realRelativeAverageIntegratedIntensity',realRelativeAverageIntegratedIntensity)
            
            realRelativeAverageIntegratedIntensityFitting = fitting.Fitting(realAccumulatedDose,realRelativeAverageIntegratedIntensity)
            
            realRelativeAverageIntegratedIntensityFitting.setContinuousX()
            
            if bfactor0 == overallBFactorFitting.coefficients[1]:
                bfactor0 = realOverallBFactorFitting.coefficients[1]
            realRelativeAverageIntegratedIntensityFitting.calculateTheoreticalIntensityDecay(beta = realOverallBFactorFitting.coefficients[0],
                                                                                 gamma = realInvRelativeScaleFitting.coefficients[0],
                                                                                 initialWilsonB= bfactor0)
            realRelativeAverageIntegratedIntensityFitting.doTheoreticalIntensityDecayCurve(resolution=resolution)
            d = realRelativeAverageIntegratedIntensityFitting.getTheoreticalDOneHalf()
            realDsOneHalf = [d] * len(realAccumulatedDose)
            dataToPlot.addListOfValuesWithKey('realD1/2',realDsOneHalf)
        
        
        #
        # Save as CSV file
        csvFilePath = os.path.join(wedge.processFolderPath,wedge.wedgeName+'.csv')
        dataToPlot.dumpToCsvFileAllKeysSorted(csvFilePath)
        
        #
        # Plot
        #
        plot1 = plot.Plot()
        plot1.createPlotDoubleYAxis(wedge.wedgeName)
        plot1.plotDiscreteValues(overallBFactorFitting.discrete_x, overallBFactorFitting.discrete_y, 
                                 plot1.ax, 'o', 'blue', 'Overall B-factor')
        plot1.plotContinuousValues(overallBFactorFitting.continuous_x, overallBFactorFitting.continuous_y,
                                   plot1.ax, 'blue')
        plot1.plotDiscreteValues(invRelativeScaleFitting.discrete_x, invRelativeScaleFitting.discrete_y, 
                                 plot1.ax2, '*', 'red', 'Relative scale')
        plot1.plotContinuousValues(invRelativeScaleFitting.continuous_x, invRelativeScaleFitting.continuous_y,
                                   plot1.ax2, 'red')
        plot1.plotDiscreteValues(relativeAverageIntegratedIntensityFitting.discrete_x, relativeAverageIntegratedIntensityFitting.discrete_y, 
                                 plot1.ax2, 's', 'green', 'Theor. rel. average integrated intensity %.2f$\AA$'%resolution)
        plot1.plotContinuousValues(relativeAverageIntegratedIntensityFitting.continuous_x, relativeAverageIntegratedIntensityFitting.continuous_y,
                                   plot1.ax2, 'green')
        
        plot1.setAxisTitles('Dose (Gy)','B-Factor ($\\AA^2$)','Relative Scale')
              
        bottomText= '$\\alpha = %.2e$ : $\\beta = %.2e$ : $D_{1/2} = %.2e$ ' \
            %(invRelativeScaleFitting.coefficients[0],
              overallBFactorFitting.coefficients[0],
              dsOneHalf[-1])
        plot1.setBottomText(bottomText)
        plot1.addLegend()
        plot1.savePlot(os.path.join(wedge.processFolderPath,wedge.wedgeName))
        if rad is not None and rad.results is not None :
            plot2 = plot.Plot()
            plot2.createPlotDoubleYAxis(wedge.wedgeName+"_Real")
            plot2.plotDiscreteValues(realOverallBFactorFitting.discrete_x, realOverallBFactorFitting.discrete_y, 
                                     plot2.ax, 'o', 'blue', 'Overall B-factor')
            plot2.plotContinuousValues(realOverallBFactorFitting.continuous_x, realOverallBFactorFitting.continuous_y,
                                       plot2.ax, 'blue')
            plot2.plotDiscreteValues(realInvRelativeScaleFitting.discrete_x, realInvRelativeScaleFitting.discrete_y, 
                                     plot2.ax2, '*', 'red', 'Relative scale')
            plot2.plotContinuousValues(realInvRelativeScaleFitting.continuous_x, realInvRelativeScaleFitting.continuous_y,
                                       plot2.ax2, 'red')
            plot2.plotDiscreteValues(realRelativeAverageIntegratedIntensityFitting.discrete_x, realRelativeAverageIntegratedIntensityFitting.discrete_y, 
                                     plot2.ax2, 's', 'green', 'Theor. rel. average integrated intensity %.2f$\AA$'%resolution)
            plot2.plotContinuousValues(realRelativeAverageIntegratedIntensityFitting.continuous_x, realRelativeAverageIntegratedIntensityFitting.continuous_y,
                                       plot2.ax2, 'green')
            
            plot2.setAxisTitles('Dose (Gy)','B-Factor ($\\AA^2$)','Relative Scale')
            
            bottomText= '$\\alpha = %.2e$ : $\\beta = %.2e$ : $D_{1/2} = %.2e$ ' \
                %(realInvRelativeScaleFitting.coefficients[0],
                  realOverallBFactorFitting.coefficients[0],realDsOneHalf[-1])
            plot2.setBottomText(bottomText)
            plot2.addLegend()
            plot2.savePlot(os.path.join(wedge.processFolderPath,wedge.wedgeName+"_real"))
                
        plot.Plot.show(draw)
                
        
    myLog.logger.info("InducedRadDam Done...")



if __name__ == "__main__":
    
    sys.exit(main()) 
